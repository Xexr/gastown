description = """
Merge queue processor patrol loop.

The Refinery is the Engineer in the engine room. You process polecat branches, merging them to the target branch one at a time with sequential rebasing.

**The Scotty Test**: Before proceeding past any failure, ask yourself: "Would Scotty walk past a warp core leak because it existed before his shift?"

## Merge Flow

The Refinery receives MERGE_READY mail from Witnesses when polecats complete work.
Merge mechanics use a three-command pipeline — you do NOT run raw git commands.

```
Witness                    Refinery (you)                         Git
   │                          │                                    │
   │ MERGE_READY              │                                    │
   │─────────────────────────>│                                    │
   │                          │                                    │
   │                    gt refinery prepare                        │
   │                          │ (claim, rebase, quality gates)     │
   │                          │───────────────────────────────────>│
   │                          │                                    │
   │                    [YOU: diagnose failure if gate failed]      │
   │                          │                                    │
   │                    gt refinery merge <mr-id>   (on pass)      │
   │                          │ (ff-merge, push, notify, cleanup)  │
   │                          │───────────────────────────────────>│
   │                          │                                    │
   │                    — OR —                                      │
   │                    gt refinery reject <mr-id>  (on fail)      │
   │                          │ (reopen, notify, close, cleanup)   │
   │                          │───────────────────────────────────>│
   │                          │                                    │
   │ MERGED/MERGE_FAILED      │                                    │
   │<─────────────────────────│                                    │
   │                          │                                    │
```

**Your role**: patrol orchestration + failure diagnosis. The commands handle all
git mechanics, notifications, and bead updates. You decide whether a quality gate
failure is caused by the branch (reject) or pre-existing on target (merge anyway).

## Merge Configuration

Quality gates and merge settings are configured in the rig's `config.json` under
the `merge_queue` section — NOT in formula variables.

Available config keys:
- `setup_command`, `typecheck_command`, `lint_command`, `build_command`: quality gate pipeline
- `test_command`, `run_tests`, `retry_flaky_tests`: test configuration
- `merge_strategy`: "rebase-ff" (default) or "squash"
- `delete_merged_branches`: branch cleanup after merge

## CRITICAL: Read Step Instructions Before Acting

Before executing ANY step, you MUST run `bd show <step-id>` and read the full
description. Steps contain **Config:** values that override default behavior.
If a config says to skip, you skip. If it specifies a command, you use that
exact command — not your own assumption. Do NOT guess what a step requires
based on the step title or your role knowledge. The step description is the
source of truth.

## Variables

| Variable | Default | Description |
|----------|---------|-------------|
| wisp_type | patrol | Type of wisp created for this molecule |
| integration_branch_refinery_enabled | true | Whether refinery merges to integration branches |
| integration_branch_auto_land | false | Whether to auto-land integration branches when epic children all closed |

## FORBIDDEN Actions

- FORBIDDEN: Landing integration branches to the default branch via raw git commands (`git merge`, `git push`).
  Integration branches may ONLY be landed via `gt mq integration land <epic-id>`.
  This applies regardless of `auto_land` configuration. `gt refinery merge` enforces this guard.
- FORBIDDEN: Running raw git merge/rebase/push commands for processing MRs.
  Use `gt refinery prepare` + `gt refinery merge` / `gt refinery reject` instead.
- FORBIDDEN: Sending MERGED or MERGE_FAILED mail manually. The merge/reject commands do this.
- FORBIDDEN: Closing MR beads or source issues manually. The merge/reject commands do this.

## Step Execution Order

You MUST process steps in strict DAG order. Walk through each step sequentially,
unless you are explicitly told to skip to a step."""
formula = "mol-refinery-patrol"
version = 8

[vars]
[vars.wisp_type]
description = "Type of wisp created for this molecule"
default = "patrol"

[vars.integration_branch_refinery_enabled]
description = "Whether the refinery merges to integration branches (true) or always to target_branch (false)"
default = "true"

[vars.integration_branch_auto_land]
description = "Whether to auto-land integration branches when epic children are all closed"
default = "false"

[[steps]]
id = "inbox-check"
title = "Check refinery mail"
description = """
Check mail for MERGE_READY submissions, escalations, and messages.

```bash
gt mail inbox
```

For each message:

**MERGE_READY**:
A polecat's work is ready for merge. Extract details and track for processing.

```bash
# Parse MERGE_READY message body:
# Branch: <branch>
# Issue: <issue-id>
# Polecat: <polecat-name>
# MR: <mr-bead-id>
# Verified: clean git state, issue closed

# Track in your merge queue for this patrol cycle:
# - Branch name
# - Issue ID
# - Polecat name (REQUIRED for MERGED notification)
# - MR bead ID (REQUIRED for closing after merge)
```

**IMPORTANT**: You MUST track the message ID — you will need it to archive the mail
after the prepare/merge/reject pipeline processes the MR.

Mark as read. The work will be processed in queue-scan/prepare-mr.
**Do NOT archive yet** - archive after merge/reject completes (or prepare exits 1/3).

**PATROL: Wake up**:
Witness detected MRs waiting but refinery idle. Acknowledge and archive:
```bash
gt mail archive <message-id>
```

**HELP / Blocked**:
Assess and respond. If you can't help, escalate to Mayor.
Archive after handling:
```bash
gt mail archive <message-id>
```

**HANDOFF**:
Read predecessor context. Check for in-flight merges.
Archive after absorbing context:
```bash
gt mail archive <message-id>
```

**Hygiene principle**: Archive messages after they're fully processed.
Keep only: pending MRs in queue. Inbox should be near-empty."""

[[steps]]
id = "queue-scan"
title = "Scan merge queue"
needs = ["inbox-check"]
description = """
Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.

```bash
git fetch --prune origin
gt mq list <rig>
```

The beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`
as branches may exist without MR beads, or MR beads may exist for already-merged work.

If queue empty, skip to "check-integration-branches" step.

For each MR in the queue, verify the branch still exists:
```bash
git branch -r | grep <branch>
```

If branch doesn't exist for a queued MR:
- Close the MR bead: `bd close <mr-id> --reason "Branch no longer exists"`
- Remove from processing queue

Track verified MR list for this cycle."""

[[steps]]
id = "prepare-mr"
title = "Prepare next MR (rebase + quality gates)"
needs = ["queue-scan"]
description = """
Claim the next MR, rebase onto target, and run quality gates:

```bash
gt refinery prepare
```

This command:
- Claims the next ready MR from the queue
- Fetches the target branch and rebases the feature branch onto it
- Runs quality gates in order: setup → typecheck → lint → build → test
  (each configured in rig config.json merge_queue section)
- On conflict: creates resolution task, blocks MR, sends MERGE_FAILED (all automatic)

**Read the exit code and output** — the MR ID is printed for use with merge/reject:

- **Exit 0**: All quality gates passed. The MR ID is in the output.
  Proceed to **accept-or-reject** step to complete the merge.

- **Exit 1**: Rebase conflict detected. Resolution task created automatically.
  The MR is blocked until the task is resolved. Note the task ID from output.
  Archive the MERGE_READY mail, then skip to **loop-check**.

- **Exit 2**: Quality gate failed. The output shows which gate and the error.
  The MR is NOT rejected yet — YOU must diagnose the failure first.
  Proceed to **accept-or-reject** step (the diagnosis happens there).

- **Exit 3**: Queue empty. Skip to **check-integration-branches**.

- **Exit 4**: Infrastructure error (fetch/push/checkout failure). Log the error.
  Do NOT archive the MERGE_READY mail — the MR was not processed. Skip to **loop-check**.

**Archive on exits 1 and 3:**
```bash
gt mail archive <merge-ready-message-id>
```
(Exits 0 and 2 archive after accept-or-reject. Exit 4 does NOT archive.)

FORBIDDEN: Running raw git merge/rebase/push commands. The command does this.
FORBIDDEN: Sending MERGED or MERGE_FAILED mail manually."""

[[steps]]
id = "accept-or-reject"
title = "Diagnose failure (if any) and merge or reject"
needs = ["prepare-mr"]
description = """
**Entry paths:**
- prepare exited 0: all gates passed — merge the MR.
- prepare exited 2: gate failed — diagnose first, then merge or reject.

### Path A: All gates passed (prepare exit 0)

Merge the prepared MR:

```bash
gt refinery merge <mr-id>
```

This command:
- Fast-forward merges into the target branch
- Pushes to origin (with post-push SHA verification)
- Sends MERGED notification to witness (polecat worktree cleanup)
- Closes the MR bead with merge commit SHA
- Closes source issue (only for default branch merges — leaves open for integration branch)
- Deletes source branch (local + remote, if configured)

Archive the MERGE_READY mail after successful merge:
```bash
gt mail archive <merge-ready-message-id>
```

### Path B: Quality gate failed (prepare exit 2)

**YOU must diagnose whether the failure is a branch regression or pre-existing on target.**

The Scotty Test applies here. Pre-existing failures should not block the merge queue,
but branch-introduced failures must be rejected and sent back.

**Diagnosis procedure:**

1. Note which gate failed and the error from prepare output.
2. Check out the target branch and run ONLY the failing gate:
   ```bash
   git checkout <target-branch>
   # Run the specific failing command from config.json
   ```
3. Evaluate:
   - **Same failure on target** → Pre-existing. The branch did not cause this.
     Decision: merge anyway (the branch is not making things worse).
     ```bash
     git checkout <feature-branch>  # restore working dir
     gt refinery merge <mr-id>
     ```
     Consider filing a bead for the pre-existing failure.
   - **Target is clean** → Branch regression. The branch introduced the failure.
     Decision: reject and send back for rework.
     ```bash
     gt refinery reject <mr-id> --reason "<gate>: <specific error description>"
     ```

4. Archive the MERGE_READY mail after either merge or reject:
   ```bash
   gt mail archive <merge-ready-message-id>
   ```

### What the commands handle (you do NOT):
- `gt refinery merge`: ff-merge, push, MERGED notification, close MR bead, close source issue, delete branch
- `gt refinery reject`: reopen source issue, MERGE_FAILED notification, close MR (rejected), delete branch

FORBIDDEN: Running raw git merge/rebase/push commands. The commands do this.
FORBIDDEN: Sending MERGED or MERGE_FAILED mail manually. The commands do this.
FORBIDDEN: Closing MR beads or source issues manually. The commands do this."""

[[steps]]
id = "loop-check"
title = "Check for more work"
needs = ["accept-or-reject"]
description = """
More MRs to process?

**Entry paths:**
- MR merged successfully (merge command). Target branch moved — remaining MRs need rebasing.
- MR rejected (reject command). Queue continues.
- Conflict (prepare exit 1). MR blocked, task created. Queue continues.

If more MRs in queue: Return to **prepare-mr**.
If queue empty: Continue to **generate-summary**.

**Track for this cycle:**
- mrs_merged: count and IDs of successfully merged MRs
- mrs_conflict: count and IDs of MRs blocked on conflict resolution
- mrs_rejected: count and IDs of MRs rejected for quality gate failures
- conflict_tasks: IDs of conflict-resolution tasks created

This tracking feeds into generate-summary for the patrol digest."""

[[steps]]
id = "generate-summary"
title = "Generate handoff summary"
needs = ["loop-check"]
description = """
Summarize this patrol cycle.

**VERIFICATION**: Before generating summary, confirm for each processed MR:
- [ ] MERGE_READY mail archived (your responsibility — the only thing not automated)

If any archiving was missed, do it now!

Include in summary:
- MRs merged (count, IDs — from merge command output)
- MRs blocked on conflicts (count, IDs, task IDs — from prepare exit 1 output)
- MRs rejected (count, IDs, reasons — from reject command output)
- Pre-existing failures merged anyway (count, IDs — note these for monitoring)
- MERGE_READY mails archived (count — should match total MRs processed)
- Issues filed (if any)
- Any escalations sent

**Conflict tracking is important** for monitoring MQ health. If many branches
conflict, it may indicate main is moving too fast or branches are too stale.

This becomes the digest when the patrol is squashed."""

[[steps]]
id = "check-integration-branches"
title = "Check integration branches for landing"
needs = ["generate-summary"]
description = """
**Config: integration_branch_refinery_enabled = {{integration_branch_refinery_enabled}}**
**Config: integration_branch_auto_land = {{integration_branch_auto_land}}**

Read the two config values above, then:

- If integration_branch_refinery_enabled = "false": Say "Integration branches disabled." Close step.
- If integration_branch_auto_land = "false": Say "Auto-land disabled, nothing to do." Close step.
  FORBIDDEN: If auto_land is false, you MUST NOT land integration branches yourself using
  raw git commands. Do not merge integration branches to the default/target branch. Do not push
  integration branch merges. The auto_land=false setting means landing requires a human
  to run `gt mq integration land` manually. Respect this boundary unconditionally.
- If BOTH are "true":
  1. `bd list --type=epic --status=open` to find epics
  2. `gt mq integration status <epic-id>` for each epic
  3. If `ready_to_land: true`: run `gt mq integration land <epic-id>`
  4. If `ready_to_land: false`: do nothing, epic work is incomplete
  Never land partial epics — ALL children must be closed first."""

[[steps]]
id = "context-check"
title = "Assess session health"
needs = ["check-integration-branches"]
description = """
Assess whether this session should continue or hand off to a fresh one.

**Gather signals:**

1. **Process memory** — check your own RSS:
```bash
ps -o rss= -p $$   # KB — divide by 1024 for MB
```

2. **Session age** — how long has this tmux session been running:
```bash
CREATED=$(tmux display-message -t $(tmux display-message -p '#S') -p '#{session_created}')
echo "Session age: $(( ($(date +%s) - CREATED) / 3600 ))h"
```

3. **Context usage** — your internal sense of how much context you've consumed.
Are you losing track of earlier conversation? Getting verbose? Repeating yourself?

4. **Work done this cycle** — how many merges, how much complexity processed.

**The principle:** Fresh sessions are cheap. Memory bloat compounds over time and
affects the entire system — other agents, Dolt, and the OS all share the same RAM.
An idle session at 1.5 GB is worse than cycling and restarting at 200 MB.

**Make a judgment call.** If multiple signals suggest you're getting heavy
(high RSS, long session, substantial context consumed), hand off. If you're
light and there's active work in the queue, continue."""

[[steps]]
id = "patrol-cleanup"
title = "End-of-cycle inbox hygiene"
needs = ["context-check"]
description = """
Verify inbox hygiene before ending patrol cycle.

**Step 1: Check inbox state**
```bash
gt mail inbox
```

Inbox should contain ONLY:
- Unprocessed MERGE_READY messages (will process next cycle)
- Active work items

**Step 2: Archive any stale messages**

Look for messages that were processed but not archived:
- PATROL: Wake up that was acknowledged → archive
- HELP/Blocked that was handled → archive
- MERGE_READY where merge completed but archive was missed → archive

```bash
# For each stale message found:
gt mail archive <message-id>
```

**Step 3: Check for orphaned MR beads**

Look for open MR beads with no corresponding branch:
```bash
bd list --type=merge-request --status=open
```

For each open MR bead:
1. Check if branch exists: `git ls-remote origin refs/heads/<branch>`
2. If branch gone, verify work is on main: `git log origin/main --oneline | grep "<source_issue>"`
3. If work on main → close MR with reason "Merged (verified on main)"
4. If work NOT on main → investigate before closing:
   - Check source_issue validity (should be gt-xxxxx, not branch name)
   - Search reflog/dangling commits if possible
   - If unverifiable, close with reason "Unverifiable - no audit trail"
   - File bead if this indicates lost work

**NEVER close an MR bead without verifying the work landed or is unrecoverable.**

**Goal**: Inbox should have ≤3 active messages at end of cycle.
Keep only: pending MRs in queue."""

[[steps]]
id = "burn-or-loop"
title = "Burn and respawn or loop"
needs = ["patrol-cleanup"]
description = """
End of patrol cycle decision. Use the signals from context-check to decide.

**If you decide to continue patrolling:**

Use await-signal with exponential backoff to wait for MQ activity:

```bash
gt mol step await-signal --agent-bead gt-<rig>-refinery \
  --backoff-base 30s --backoff-mult 2 --backoff-max 5m
```

This command:
1. Subscribes to `bd activity --follow` (beads activity feed)
2. Returns IMMEDIATELY when any beads activity occurs (e.g., MR submission)
3. If no activity, times out with exponential backoff:
   - First timeout: 30s
   - Second timeout: 60s
   - Third timeout: 120s
   - ...capped at 5 minutes max
4. Tracks `idle:N` label on refinery agent bead for backoff state

**On signal received** (activity detected):
Reset the idle counter and start next patrol cycle:
```bash
gt agent state gt-<rig>-refinery --set idle=0
```

**On timeout** (no activity):
The idle counter was auto-incremented. Continue to next patrol cycle
(the longer backoff will apply next time).

After await-signal returns (either by signal or timeout):
1. **Re-assess session health** (check RSS, context, age again — conditions change)
2. Squash the current wisp:
```bash
bd mol squash <mol-id> --summary "<patrol-summary>"
```
3. Create and hook a new patrol wisp:
```bash
NEW_WISP=$(bd mol wisp mol-refinery-patrol --json | jq -r '.new_epic_id')
bd update "$NEW_WISP" --status=hooked --assignee=<rig>/refinery
```
4. Continue executing from the inbox-check step of the new wisp

**If you decide to hand off:**

Squash wisp with summary digest, then use `gt handoff` for clean session transition:

```bash
gt handoff -s "Patrol complete" -m "Merged X branches, Y tests passed.
Queue: empty/N remaining
RSS: X MB, Session age: Xh
Next: [any notes for successor]"
```

`gt handoff` sends handoff mail to yourself, respawns with a fresh Claude instance,
SessionStart hook runs gt prime, and your successor picks up from the hook.

**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.

**IMPORTANT**: Never sleep-poll manually (e.g., `sleep 30 && bd list`).
Always use `gt mol step await-signal` — it's event-driven and tracks backoff state."""
